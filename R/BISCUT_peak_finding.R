### Author: Juliann Shih, jshih@broadinstitute.org
### Contact: Rameen Beroukhim, rameen_beroukhim@dfci.harvard.edu
### Date last updated: July 24, 2023

### License: GNU GPL2, Copyright (C) 2023 Dana-Farber Cancer Institute
### Dependencies: tested using R 4.1 and Python 3.9
### See README for guide on how to run this package

##################################################

#' Run BISCUT analysis on processed arm breakpoint files
#' 
#' @param breakpoint_file_dir Directory holding breakpoint files as generated by
#'   make_breakpoint_files().
#' @param results_dir The path for a results directory that will be created on running.
#' @param use_precalculated_background TRUE/FALSE (default FALSE) on whether to use a precalculated
#'   background distribution from TCGA samples. When FALSE, a background distribution is calculated
#'   from input data.
#' @param ci Confidence interval threshold around peaks (larger values will yield wider peaks).
#' @param n_bootstrap Number of bootstrapped samples for calculating confidence intervals
#' @param telcent_thres Threshold to filter out very short or whole-arm events to correct for noise
#'   in calling copy number breakpoints. Events that cover a fraction of an arm that is less than
#'   \code{telcent_thres} or greater than \code{(1-telcent_thres)} are removed. Increase the
#'   threshold if you have peaks called too close to the telomere/centromere that you think are not
#'   real.
#' @param qval_thres The threshold on q-values computed for the significance of identified peaks
#'   after correcting for multiple hypothesis testing
#' @param arms Which chromosome arms to analyze. By default, all arms.
#' @param cores How many cores to use for processing chromosome arms in parallel. As always with the
#'  \code{parallel} library, use of multiple cores is not supported on Windows systems.
#' @param chromosome_coordinates The coordinates of p and q arms of the human chromosomes. By
#'   default, hg19-based coordinates are used. Please note that these coordinates are not
#'   biologically well-defined regions but rather what appeared to be the boundaries of regions that
#'   can be considered telomeric and (particularly) centromeric from SNP-array based TCGA copy
#'   number profiles. You might want to use your custom set of coordinates based on your copy number
#'   profiles (ex. IGV view of start/end of event near telomere/centromere). From our experience,
#'   choosing the telomeric/centromeric boundaries wide enough so that the events are not missed due
#'   to imperfections of assaying technologies is more important than genome reference differences
#'   (ex., hg19 vs. hg38).
#' @param gene_locations Gene locations for mapping genes to peaks in the output. By default, an hg19-based
#' table is used; see \code{get_gene_locations()}.
#' @param seed Default NULL; supply an integer seed to make numerical output reproducible.
#' @export
do_biscut = function(breakpoint_file_dir, results_dir, use_precalculated_background = FALSE,
                     telcent_thres = 1e-3, ci = .95, n_bootstrap = 1000, qval_thres = .05, cores = 1,
                     arms = get_chromosome_arms(), chromosome_coordinates = get_chromosome_coordinates(), 
                     gene_locations = get_gene_locations(), seed = NULL) {
  bgdist <- 'beta'
  
  if(! is.null(seed)) {
    if(! rlang::is_integerish(seed) || length(seed) != 1) {
      stop('seed should be an integer (or left NULL).')
    }
  }
  
  if(! rlang::is_bool(use_precalculated_background)) {
    stop('use_precalculated_background should be TRUE/FALSE.')
  }
  if(! rlang::is_double(telcent_thres, finite = T) || length(telcent_thres) != 1 || telcent_thres <= 0 || telcent_thres >= 1) {
    stop('telcent_thres must be a scalar numeric on the interval (0, 1).')
  }
  if(! rlang::is_double(ci, finite = T) || length(ci) != 1 || ci <= 0 || ci >= 1) {
    stop('ci must be a scalar numeric on the interval (0, 1).')
  }
  if(! rlang::is_double(qval_thres, finite = T)|| length(qval_thres) != 1 || qval_thres <= 0 || qval_thres >= 1) {
    stop('qval_thres must be a scalar numeric on the interval (0, 1).')
  }
  if(! rlang::is_scalar_integerish(n_bootstrap, finite = T) || n_bootstrap < 1) {
    stop('n_bootstrap must be a positive integer')
  }
  
  if(! is.character(breakpoint_file_dir) || length(breakpoint_file_dir) != 1) {
    stop('breakpoint_file_dir should be 1-length character (a path to breakpoint files).')
  }
  if(! dir.exists(breakpoint_file_dir)) {
    stop('Specified breakpoint_file_dir does not exist.')
  }
  breakpoint_file_dir = normalizePath(breakpoint_file_dir)
  
  if (use_precalculated_background) {
    tel = filter_big_small(default_background_data$tel, telcent_thres)
    cent = filter_big_small(default_background_data$cent, telcent_thres)
  } else {
    custom_background_data = load_breakpoint_files(breakpoint_file_dir, telcent_thres = telcent_thres)
    tel = custom_background_data$tel
    cent = custom_background_data$cent
  }
  
  
  if(! rlang::is_scalar_integerish(cores) || ! is.finite(cores) || cores < 1) {
    stop('cores should be positive integer')
  }
  max_cores = parallel::detectCores()
  if(cores > max_cores) {
    message('Running with ', max_cores, " detected cores.")
    cores = max_cores
  }
  
  # Validate results directory
  if(! is.character(results_dir) || length(results_dir) != 1 || nchar(results_dir) == 0) {
    stop('results_dir should be 1-length character (specifically, a path where output should be saved).')
  }
  if(! dir.exists(dirname(results_dir))) {
    stop('Parent directory for input results_dir (', dirname(results_dir), ' does not exist.')
  }
  if(dir.exists(results_dir)) {
    stop('Specified results_dir directory ', results_dir, ' already exists.')
  }
  
  if(! is.character(arms) || length(arms) == 0) {
    stop('arms should be a character vector of chromosome arms (see get_chromosome_arms())')
  }
  arms = unique(arms)
  bad_arms = setdiff(arms, get_chromosome_arms())
  if(length(bad_arms) > 0) {
    stop('Unrecognized arms: ', paste0(bad_arms, collapse = ', '), '.')
  }
  
  abslocs = validate_chr_coordinates(chromosome_coordinates)
  genelocs = validate_gene_locations(gene_locations)
  
  # Fit all the empirical distributions
  amptelemp <- tel[tel$amp_del=='amp', 'percent']
  deltelemp <- tel[tel$amp_del=='del', 'percent']
  ampcentemp <- cent[cent$amp_del=='amp', 'percent']
  delcentemp <- cent[cent$amp_del=='del', 'percent']
  
  emp_by_type = list()
  emp_by_type[['amp']][['tel']] = amptelemp
  emp_by_type[['del']][['tel']] = deltelemp
  emp_by_type[['amp']][['cent']] = ampcentemp
  emp_by_type[['del']][['cent']] = delcentemp 
  
  fit_by_type = list()
  fit_by_type[['amp']][['tel']] = fitdistrplus::fitdist(amptelemp, bgdist)
  fit_by_type[['del']][['tel']] = fitdistrplus::fitdist(deltelemp, bgdist)
  fit_by_type[['amp']][['cent']] = fitdistrplus::fitdist(ampcentemp, bgdist)
  fit_by_type[['del']][['cent']] = fitdistrplus::fitdist(delcentemp, bgdist)
  
  if(! dir.create(results_dir)) {
    stop('Could not create results_dir.')
  }
  results_dir = normalizePath(results_dir)
  dir.create(paste0(results_dir, '/peak_plots'))
  
  finished_processing = FALSE
  on.exit({
    if(! finished_processing) {
      unlink(results_dir, recursive = T)
      message('Run(s) failed. Deleted incomplete output directory.')
    }
  })
  
  
  # Advise regarding cores option
  if(cores == 1 && max_cores > 1) {
    message("Running with 1 core. Restart with more cores (argument \"cores = ...\") if you want to reduce runtime.")
  }
  
  message("Running BISCUT...")
  run_args = expand.grid(d = c('amp', 'del'), tc =c('cent', 'tel'), a = arms, stringsAsFactors = FALSE)
  if(! is.null(seed)) {
    seed = set.seed(seed)
    seeds = sample(1:1e7, size = nrow(run_args), replace = FALSE)
    run_args$seed = seeds
  }
  results = pbapply::pblapply(1:nrow(run_args),
                                 function(i) {
                                   direc = run_args$d[i]
                                   telcent = run_args$tc[i]
                                   emp = emp_by_type[[direc]][[telcent]]
                                   fit = fit_by_type[[direc]][[telcent]]
                                   seed = run_args$seed[i]
                                   do_arm_gistic(arm = run_args$a[i],
                                                 direc = direc,
                                                 telcent = telcent,
                                                 mode = 'overlap',
                                                 ci = ci,
                                                 qval_thres = qval_thres,
                                                 telcent_thres = telcent_thres,
                                                 breakpoint_file_dir = breakpoint_file_dir,
                                                 n = n_bootstrap,
                                                 emp_bg = list(emp = emp, fit = fit),
                                                 results_dir = results_dir,
                                                 abslocs = abslocs,
                                                 genelocs = genelocs,
                                                 seed = seed)
                                 }, cl = cores)
  which_failed = which(! sapply(results, is.data.table))
  if(length(which_failed) > 0) {
    warning(paste0('Run(s) failed. Attempting to return debugging information.\n',
                   'Try running a failing arm with cores = 1 for more a detailed error message.'))
    failed_runs = results[which_failed]
    for(i in 1:length(which_failed)) {
      ind = which_failed[i]
      failed_runs[[i]] = list(error = failed_runs[[i]], 
                              args = c(arm = run_args$a[ind],
                                          direc = run_args$d[ind],
                                          telcent = run_args$t[ind]))
    }
    return(failed_runs)
  }
  results = rbindlist(results)

  # Produce a single file of p-values, KS_pvalues (keeping original column names for this file)
  pvalues = unique(results[, .(peak_id, one_samp_p = ks_p, ks_stat)])
  pvalues[, by := p.adjust(one_samp_p, method = 'BY')]
  pvalues[, bonferroni := p.adjust(one_samp_p, method='bonferroni')]

  pvalue_file = paste0(results_dir, '/', 'KS_pvalues.txt')
  fwrite(pvalues, file = pvalue_file, sep='\t')
  
  # Merge in BY-corrected p-values
  results[pvalues, ksby := by, on = 'peak_id']
  results[ksby == 0, log10_ksby := 16] # max reported value
  results[ksby != 0, log10_ksby := -log10(ksby)]
  results[, combined_sig := ks_stat * log10_ksby]
  
  # Find peaks that fail multiple discovery correction, remove them and all their children
  peak_id_to_remove = results[ksby > qval_thres, unique(peak_id)]
  while(TRUE) {
    found_so_far = length(peak_id_to_remove)
    more_to_remove = results[parent %in% peak_id_to_remove, unique(peak_id)]
    peak_id_to_remove = union(peak_id_to_remove, more_to_remove)
    if(length(peak_id_to_remove) == found_so_far) break
  }
  results = results[! peak_id_to_remove, on = 'peak_id'] # Still works when peak_id_to_remove is character(0)
  results$parent = NULL
  
  results[direction == 'del' & negpos == 'p', type_of_selection := 'TS-like']
  results[direction == 'del' & negpos == 'n', type_of_selection := 'essential-like']
  results[direction == 'amp' & negpos == 'p', type_of_selection := 'onco-like']
  results[direction == 'amp' & negpos == 'n', type_of_selection := 'toxic-like']
  results[, peak_interval := paste0(Chr, ':', Peak.Start, '-', Peak.End)]
  setcolorder(results, c('peak_id', 'code', 'peak_interval'))
  results = results[order(-combined_sig)]
  
  fwrite(results, paste0(results_dir, '/all_BISCUT_results.txt'), sep = "\t")
  
  # Take only most significant result for each gene, by type
  gene_rank = results[order(combined_sig, decreasing = T), .SD[!duplicated(Gene)], .SDcols = c('Gene', 'combined_sig'), 
                          by = c('direction', 'negpos')]
  
  rnk  = gene_rank[! duplicated(Gene), .(Gene, combined_sig)]
  aprnk = gene_rank[direction == 'amp' & negpos == 'p', .(Gene, combined_sig)]
  dprnk = gene_rank[direction == 'del' & negpos == 'p', .(Gene, combined_sig)]
  anrnk = gene_rank[direction == 'amp' & negpos == 'n', .(Gene, combined_sig)]
  dnrnk = gene_rank[direction == 'del' & negpos == 'n', .(Gene, combined_sig)]
  tsrnk = rbind(dprnk, anrnk)[order(combined_sig, decreasing = T)][! duplicated(Gene)]
  oncrnk = rbind(dnrnk, aprnk)[order(combined_sig, decreasing = T)][! duplicated(Gene)]
  
  rnk_with_name = list(
    signif_genes = rnk,
    `signif_ts-like` = tsrnk,
    `signif_onk-like` = oncrnk,
    `signif_amp-pos` = aprnk,
    `signif_del-pos` = dprnk,
    `signif_amp-neg` = anrnk,
    `signif_del-neg` = dnrnk
  )
  
  ranked_gene_dir = paste0(results_dir, '/signif_ranked_genes')
  dir.create(ranked_gene_dir)
  
  mapply(function(filename, dt) {
      filename = paste0(ranked_gene_dir, '/', filename, '.txt')
      fwrite(dt, file = filename, sep = "\t")
    }, names(rnk_with_name), rnk_with_name)
  
  
  #call the function to combine BISCUT results and process some files for plotting
  reticulate::source_python(system.file('python/combine_BISCUT_results.py', package = 'BISCUT'))
  
  # selectedgenes = c('CDKN2A','TERT','MYC','BAP1','TERC','TP53','ARID1A','EGFR','PPM1D')
  
  # Generate file describing peak overlaps
  rownames(genelocs) = 0:(nrow(genelocs) - 1)
  calc_overlaps(results_dir, genelocs)
  
  # Write arm-level data for "figure 2"-style plotting (unsure if the actual plotting code is working as intended)
  filter_BISCUT_arms(results_dir, arms)
  
  # Make summary plots
  plot_dir = paste0(results_dir, '/summary_plots')
  dir.create(plot_dir)
  
  abslocs_dt = as.data.table(abslocs) # for simpler merging into peak data
  if(! 'offset' %in% names(abslocs_dt)) {
    abslocs_dt$size = as.numeric(abslocs_dt$size) # avoid integer overflow (!)
    abslocs_dt[, offset := c(0, cumsum(abslocs_dt$size[1:(.N - 1)]))]
  }
  
  for_plots = copy(results)
  for_plots[direction == 'del', log10_ksby := -1 * log10_ksby]
  for_plots[, combined_sig := log10_ksby * ks_stat]
  
  darkred = '#a50f15'
  lightred = '#fcae91'
  lightblue = '#6baed6'
  darkblue = '#08519c'
  
  # Merge in offset (effectively converting chromosome coordinates to a genome-wide coordinate system)
  for_plots[abslocs_dt, offset := offset, on = c(Chr = 'chromosome_info')]
  for_plots[, xmin := Peak.Start + offset]
  for_plots[, xmax := Peak.End + offset]
  for_plots[, ymin := pmin(0, combined_sig)]
  for_plots[, ymax := pmax(0, combined_sig)]
  
  write_plot_data = function(dt, name, neg_color, pos_color) {
    if(dt[, .N] == 0) {
      return()
    }
    output_file = paste0(plot_dir, '/plot_data_', name, '.txt')
    dt[pmin(ymin, ymax) < 0, color := neg_color]
    dt[pmax(ymin, ymax) > 0, color := pos_color]
    output = dt[, .(peak_id, direction, type_of_selection, xmin, xmax, ymin, ymax, color)]
    fwrite(output, file = output_file, sep = "\t")
    return(output)
  }
  
  amp_data = write_plot_data(for_plots[direction == 'amp'], name = 'amp', neg_color = lightblue, pos_color = darkred)
  del_data = write_plot_data(for_plots[direction == 'del'], name = 'del', neg_color = lightred, pos_color = darkblue)
  pos_data = write_plot_data(for_plots[negpos == 'p'], name = 'pos', neg_color = darkblue, pos_color = darkred)
  neg_data = write_plot_data(for_plots[negpos == 'n'], name = 'neg', neg_color = lightred, pos_color = lightblue)
  
  xlab1 = "Significance\nnegative selection <----------------------------------------------> positive selection"
  amp_plot = plot_BISCUT_results(amp_data, title = 'Amplifications', xlab = xlab1, abslocs = abslocs)
  del_plot = plot_BISCUT_results(del_data, title = 'Deletions', xlab = xlab1, abslocs = abslocs)
  
  xlab2 = "Significance\nessential-like <----------------------------------------------> toxic-like"
  neg_plot = plot_BISCUT_results(neg_data, title = 'Negative Selection', xlab = xlab2, abslocs = abslocs)
  
  xlab3 = "Significance\ntumor-suppressor-like <----------------------------------------------> oncogene-like"
  pos_plot = plot_BISCUT_results(pos_data, title = 'Positive Selection', xlab = xlab3, abslocs = abslocs)
  
  if(amp_data[, .N] > 0) {
    cowplot::save_plot(filename = paste0(plot_dir, '/BISCUT_peaks_', 'amplifications.pdf'), amp_plot,
                       base_width = 8, base_height = 6)
  }
  if(del_data[, .N] > 0) {
    cowplot::save_plot(filename = paste0(plot_dir, '/BISCUT_peaks_', 'deletions.pdf'), del_plot,
                       base_width = 8, base_height = 6)
  }
  if(pos_data[, .N] > 0) {
    cowplot::save_plot(filename = paste0(plot_dir, '/BISCUT_peaks_', 'positive_selection.pdf'), pos_plot,
                       base_width = 8, base_height = 6)
  }
  if(neg_data[, .N] > 0) {
    cowplot::save_plot(filename = paste0(plot_dir, '/BISCUT_peaks_', 'negative_selection.pdf'), neg_plot,
                       base_width = 8, base_height = 6)
  }
  
  finished_processing = TRUE
  
  peak_info = results[! duplicated(peak_id), .(peak_id, peak_interval, type_of_selection, combined_sig, 
                                   Chr, Peak.Start, Peak.End, Peak.Start.1, Peak.End.1,
                                   n_events, n_right, n_left, code, negpos, iter, arm, direction, telcent,
                                   ks_stat, log10_ks_p, log10_ksby)]
  gene_cols = setdiff(names(results), c(names(peak_info), c('conf', 'ksby', 'ks_p')))
  genes_by_peak = results[, .SD, .SDcols = c('peak_id', gene_cols, 'combined_sig')][order(-combined_sig, Start)]
  setnames(genes_by_peak, 'combined_sig', 'peak_combined_sig')
  return(list(peaks = peak_info, genes_by_peak = genes_by_peak, background_fits = fit_by_type))
}

